const userData = { 
   name: 'Akhmed',
   people: true,
   age: 25
}


/*-------------У них такие же методы как у массивов , но длина картежа указывается первоначально, она изменится в js но тут будет указана ошибка при попытке использовать элемент с индексом больше длины мпервоначлаьного массива-------------------*/

const userDataTuple: [string , boolean , number] = ['Akhmed' , true , 25];      //Картеж указывается в нужном порядке только! 

/*------------Разница в картеже и массиве в том что в массиве указывается сразу типизация всех элементов а в картеже указывается единичная для каждого элемента массива по порядку -------------------*/
/*-------------Картежи нужны для хранения данных определенного типа в строго заданном порядке-------------------*/
//Порядок нельзя менять но там не написаны ключи по значениям и чтобы орентироваться в коде нужны комментарии, поэтому его используют не атк часто

// userDataTuple[3];
// userDataTuple.push(50);
// userDataTuple[3];

const res = userDataTuple.map((t)=> `${t}+50`);

const [nameUs , bdh , age] = userDataTuple;
//useState возвращает картеж

//если хотите добавить в картеж неопределенное количество элементов определенного типа например в конце то надо записать их как массив со спред оператором 

const userSpred: [string , boolean , ...number[]] = ['Akhmed' , true , 10 , 20 , 200 , 199 ];

//такое расширение можно сдлетаь лишь одно так как потом если сделатьих несколько то уже не получистя указать где именно будут находиться другие элементы
//теперь как сделать диструктуризацию?
//то есть сначала рест оператором я собираю обратно все в один массив , а после я уже диструктуризаиурю данный массив
const [nans , trs , ...agess] = userSpred;


const [nan , tr , ...[ag1, ag2, ag3, ag4]] = userSpred;
console.log(ag1, ag2, ag3 ,ag4);