/*-------------Первоначально скажем что в массивах TSC пытаются максимально сузить типизацию, то есть всем элементам одного массива пытаются дать одинкаывый тип, если этого не получается то используется тип any[] , так же для работы с массивами используют кортежи (как для объектов интерфейсы-------------------*/

/// Указано что данная переменная является массивом внутри которго строго типизированные элементы под строку, теперь вытаскивая элементы с данного массива, автоматом получится строка и нельзя изменить элемент массива на другой тип (док на 6)
const arrayStr: string[] = ['a' , 'any' , 'bbbbb'];

// arrayStr[2] = 2;


/*-------------Существуют массивы в массивах для того чтобы уазать что внутри массива будет находиться другой массив необходимо указать две скобки string[][] в данном случае указывается что во внутреннем массиве элементы будут типа строки , но при map необходимо будет вновь указывать что элемент явяется строкой так как в map можно менять тип если он не указан-------------------*/

const VlojArray: number[][] = [[ 1 , 2, 4, 0] , [10 ,12]];

const numberAr = VlojArray[0]
                            .map((num:number , index) => num+ index)
                           //  .map(num => { return '123' } );
console.log(numberAr);

///Повтор диструктуризации в объектах , тут я сразу узаываю типизацию так как потом не использую данную переменную в других функциях а так я бы указывал типипзацию уже на этапе использования данной переменной внутри функции
const people: { name: string , age:number } = { 
   name:`ak`,
   age: 25
}
const {name: An , age: AA} = people

///Диструктуризация в array происходит как обычно в JS
const [first] = numberAr

console.log(first);